### Java语言特性

编译器生成字节码，可在任何机器上解释执行，但肯定比全速运行机器指令慢很多。但虚拟机可将使用频繁的字节码系列翻译成机器码，这个操作为即时编译，很有效。

`JDK` ：`Java` 开发工具箱

`JRE` : `Java` 运行时环境，包含虚拟机但不包含编译器

### Switch语句

有可能触发多个 `case` 分支，若在 `case` 分支末尾没有 `break`，会接着执行下一个 `case` 分支，很危险。

### 类之间的关系

**依赖**：一个类的方法操纵另一个类的对象，应该将互相依赖的类减至最少

**聚合**：一个类的对象包含另一个类的对象

**继承**：一个类扩展自另一个类

### 对象变量

一个对象变量并没有实际包含一个对象，仅仅引用一个对象。任何对象变量的值都是对存储在另外一个地方的一个对象的引用。

### 方法参数

`Java` 采用的是值调用。一个方法不能修改基本数据类型参数，不能让对象参数引用一个新对象。

### 方法重载

允许多个方法有相同的名字，不同的参数。返回类型不是方法签名的一部分

### 对象初始化步骤

1. 所有数据域初始化为默认值
2. 按类声明出现的次序，依次执行所有域初始化语句和初始化块
3. 执行构造器

### finalize方法

相当于析构器方法，在垃圾回收器清除对象之前调用。不要用该方法回收资源，因为不知道该方法什么时候才会调用。

### 类路径

虚拟机寻找类先从 `jre/lib` 和 `jre/lib/ext` 搜索，随后再搜索指定的类路径。设置类路径：

```shell
java -classpath /home/user/classdir:.:/home/user/archives/archive.jar
```

### 反射

在程序运行期间发现更多的类及其属性的能力。

### this和super

`this` 是一个对象的引用，表示当前对象；`super` 不是一个对象的引用，不能将 `super` 赋给另一个对象变量，只是一个指示编译器调用超类方法的特殊关键字。

### 动态绑定

根据变量类型决定是调用父类方法还是子类方法

### final关键字

1. 修饰类：该类不能被继承
2. 修饰方法：该方法不能被重写
3. 修饰变量：该变量一旦被赋值，不能被改变

### hashCode方法

两个不同对象的散列值一般不同，如果重写 `equals` 方法，也要重写 `hashCode` 方法。

### 反射

`Java` 运行时会始终为所有对象维护一个被称为运行时的类型标识，追踪每个对象所属的类，保存运行时类型信息。这些是由 `Class` 类来做的。

### 内部类

内部类的对象总有一个隐式引用，指向创建它的外部类对象，外部类的引用在构造器中设置。只有内部类可以声明称私有。

如果内部类只在一个方法中使用一次，可以在一个方法中定义局部类。局部类不能用 `public` 或 `private` 修饰，作用域被限定在声明这个局部类的块中。优势是对外部世界完全隐藏起来。另一个优势，不仅可以访问包含它们的外部类，还可以访问 `final` 局部变量。局部类在局部变量被释放前进行备份。

内部类不需要访问外部类对象的时候，应该使用静态内部类，只有内部类能用 `static` 修饰。

### 代理

使用代理可以在运行时创建一个实现了一组给定接口的新类。在编译时无法确定需要实现哪个接口时才有必要使用。代理类可以在运行时创建全新的类，实现指定的接口。但是不能在运行时定义这些方法的新代码，需要提供一个实现了 `InvocationHandler` 接口的调用处理器。这样调用代理对象的方法，调用处理器的 `invoke` 对象会被调用。

创建代理对象，需要使用 `Proxy` 类的 `newProxyInstance` 方法，有三个参数：类加载器、 `Class` 对象数组和一个调用处理器。

使用代理对象的原因：路由对远程服务器的方法调用；在程序运行期间，将用户接口事件与动作关联起来；为调试、跟踪方法调用。

代理类只有调用处理器一个实例域，所需要的任何附加数据都必须存储在调用处理器中。

### 泛型

增加程序的安全性和可读性。虚拟机没有泛型类型对象，所有对象都属于普通类。每定义一个泛型类型，都自动提供一个原始类型，名字就是删去类型参数后的泛型类型名。擦除类型变量后，替换为限定类型。原始类型用第一个限定的类型变量来替换，如果没有给定限定就用 `Object` 替换。